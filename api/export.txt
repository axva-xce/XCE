
account.js: 
import { readAccount, writeAccount, findAccount } from "./db.js"; export async function upsertAccount({ username, sub, email }) { if (!username) throw new Error("No username passed to upsertAccount"); let acct = await readAccount(username); if (!acct) { let emailToSave = email || ""; if (email) { const existingUserWithEmail = await findAccount(a => a.email === email); if (existingUserWithEmail) { console.warn(`[upsertAccount] Email '${email}' from Stripe is already in use by user '${existingUserWithEmail.username}'. The new user '${username}' will have a blank email.`); emailToSave = "" } } console.warn(`[upsertAccount] User '${username}' not found. Creating new stub account.`); acct = { username, passwordHash: "", email: emailToSave, tier: "T1", status: "free", stripeSubscriptionId: null, currentPeriodEnd: 0 } } const item = sub.items?.data?.[0]; acct.stripeSubscriptionId = sub.id; acct.tier = tierFromPrice(item?.price ?? {}); acct.currentPeriodEnd = sub.current_period_end ?? item?.current_period_end ?? 0; acct.status = acct.tier === "T1" ? "free" : "active"; await writeAccount(acct); return acct } function tierFromPrice(price) { switch (price.id) { case process.env.PRICE_ID_T2: return "T2"; case process.env.PRICE_ID_T3: return "T3"; default: return "T1" } } 
db.js: 
import { Redis } from "@upstash/redis"; const redis = new Redis({ url: process.env.UPSTASH_REDIS_REST_URL, token: process.env.UPSTASH_REDIS_REST_TOKEN }); export async function readAccount(username) { if (!username) return null; const account = await redis.hgetall(`account:${username}`); return account && account.username ? account : null } export async function writeAccount(account) { if (!account || !account.username) { throw new Error("writeAccount requires an account object with a username") } const tx = redis.multi(); tx.hset(`account:${account.username}`, account); tx.sadd("usernames", account.username); await tx.exec() } export async function listUsernames() { return await redis.smembers("usernames") } export async function findAccount(predicate) { const allUsernames = await listUsernames(); for (const username of allUsernames) { const account = await readAccount(username); if (account && predicate(account)) { return account } } return undefined } 
export.txt: 

account.js: 
import { readAccount, writeAccount, findAccount } from "./db.js"; export async function upsertAccount({ username, sub, email }) { if (!username) throw new Error("No username passed to upsertAccount"); let acct = await readAccount(username); if (!acct) { let emailToSave = email || ""; if (email) { const existingUserWithEmail = await findAccount(a => a.email === email); if (existingUserWithEmail) { console.warn(`[upsertAccount] Email '${email}' from Stripe is already in use by user '${existingUserWithEmail.username}'. The new user '${username}' will have a blank email.`); emailToSave = "" } } console.warn(`[upsertAccount] User '${username}' not found. Creating new stub account.`); acct = { username, passwordHash: "", email: emailToSave, tier: "T1", status: "free", stripeSubscriptionId: null, currentPeriodEnd: 0 } } const item = sub.items?.data?.[0]; acct.stripeSubscriptionId = sub.id; acct.tier = tierFromPrice(item?.price ?? {}); acct.currentPeriodEnd = sub.current_period_end ?? item?.current_period_end ?? 0; acct.status = acct.tier === "T1" ? "free" : "active"; await writeAccount(acct); return acct } function tierFromPrice(price) { switch (price.id) { case process.env.PRICE_ID_T2: return "T2"; case process.env.PRICE_ID_T3: return "T3"; default: return "T1" } } 
db.js: 
import { Redis } from "@upstash/redis"; const redis = new Redis({ url: process.env.UPSTASH_REDIS_REST_URL, token: process.env.UPSTASH_REDIS_REST_TOKEN }); export async function readAccount(username) { if (!username) return null; const account = await redis.hgetall(`account:${username}`); return account && account.username ? account : null } export async function writeAccount(account) { if (!account || !account.username) { throw new Error("writeAccount requires an account object with a username") } const tx = redis.multi(); tx.hset(`account:${account.username}`, account); tx.sadd("usernames", account.username); await tx.exec() } export async function listUsernames() { return await redis.smembers("usernames") } export async function findAccount(predicate) { const allUsernames = await listUsernames(); for (const username of allUsernames) { const account = await readAccount(username); if (account && predicate(account)) { return account } } return undefined } 
export.txt: 

account.js: 
import { readAccount, writeAccount, findAccount } from "./db.js"; export async function upsertAccount({ username, sub, email }) { if (!username) throw new Error("No username passed to upsertAccount"); let acct = await readAccount(username); if (!acct)  
login.js: 
import bcrypt from 'bcrypt'; import jwt from 'jsonwebtoken'; import { readAccount } from './db'; export default async function handler(req, res) { if (req.method !== 'POST') { return res.status(405).end() } let username, password; try { const body = typeof req.body === 'string' ? JSON.parse(req.body) : req.body; username = body.username; password = body.password } catch (e) { return res.status(400).json({ error: 'Invalid JSON' }) } if (!username || !password) { return res.status(400).json({ error: 'Username and password required' }) } const acct = await readAccount(username); if (!acct || !(await bcrypt.compare(password, acct.passwordHash))) { return res.status(401).json({ error: 'Invalid credentials' }) } const token = jwt.sign({ username: acct.username }, process.env.JWT_SECRET, { expiresIn: '1h' }); res.json({ token }) } 
request-password-reset.js: 
import { findAccount } from './db'; import nodemailer from 'nodemailer'; import { Redis } from '@upstash/redis'; console.log('[request-password-reset.js] Module loading...'); let redisClientForCodes; let essentialEnvVarsOk = true; if (!process.env.UPSTASH_REDIS_REST_URL) { console.error('[request-password-reset.js] FATAL ERROR: UPSTASH_REDIS_REST_URL environment variable is not set.'); essentialEnvVarsOk = false } if (!process.env.UPSTASH_REDIS_REST_TOKEN) { console.error('[request-password-reset.js] FATAL ERROR: UPSTASH_REDIS_REST_TOKEN environment variable is not set.'); essentialEnvVarsOk = false } if (!process.env.EMAIL_USER) { console.error('[request-password-reset.js] FATAL ERROR: EMAIL_USER environment variable is not set.'); essentialEnvVarsOk = false } if (!process.env.EMAIL_PASS) { console.error('[request-password-reset.js] FATAL ERROR: EMAIL_PASS environment variable is not set.'); essentialEnvVarsOk = false } if (essentialEnvVarsOk) { try { redisClientForCodes = new Redis({ url: process.env.UPSTASH_REDIS_REST_URL, token: process.env.UPSTASH_REDIS_REST_TOKEN, }); console.log('[request-password-reset.js] Redis client for codes initialized.') } catch (e) { console.error('[request-password-reset.js] FATAL ERROR: Could not initialize Redis client for codes.', e); essentialEnvVarsOk = false } } else { console.error('[request-password-reset.js] Skipping Redis client initialization due to missing essential environment variables.') } console.log(`[request-password-reset.js] Essential Env Vars OK: ${essentialEnvVarsOk}`); export const config = { api: { bodyParser: true, }, }; function generateResetCode() { return Math.floor(100000 + Math.random() * 900000).toString() } export default async function handler(req, res) { console.log(`[Handler] /api/request-password-reset ${req.method} invoked. Request ID: ${req.headers['x-vercel-id'] || 'N/A'}`); if (!essentialEnvVarsOk || !redisClientForCodes) { console.error(`[Handler] Cannot process request. Essential setup failed.`); return res.status(500).json({ error: 'Server configuration error. Service unavailable.' }) } if (req.method !== 'POST') { res.setHeader('Allow', 'POST'); return res.status(405).json({ error: `Method ${req.method} Not Allowed` }) } let emailToReset; try { const requestBody = typeof req.body === 'string' ? JSON.parse(req.body) : req.body; emailToReset = requestBody.email; if (!emailToReset || typeof emailToReset !== 'string') { console.warn('[Handler] Missing or invalid email in request body:', req.body); return res.status(400).json({ error: 'Email is required' }) } } catch (err) { console.error('[Handler] Invalid JSON in request body', err); return res.status(400).json({ error: 'Invalid JSON' }) } console.warn(`[Handler] Password reset requested for email: ${emailToReset}`); try { const accountExists = await findAccount(acc => acc.email === emailToReset); if (accountExists) { console.warn(`[Handler] Account found for email: ${emailToReset} (user: ${accountExists.username}). Initiating password reset.`); const resetCode = generateResetCode(); const redisKey = `password_reset_code:${emailToReset}`; await redisClientForCodes.set(redisKey, resetCode, { ex: 15 * 60 }); const transporter = nodemailer.createTransport({ host: 'smtp.office365.com', port: 587, secure: false, auth: { user: process.env.EMAIL_USER, pass: process.env.EMAIL_PASS, }, tls: { ciphers: 'SSLv3' } }); const mailOptions = { from: `"XCE No Reply" <${process.env.EMAIL_USER}>`, to: emailToReset, subject: 'Your XCE Password Reset Code', text: `Hello ${accountExists.username || 'User'},\n\nYour password reset code is: ${resetCode}\n\nThis code will expire in 15 minutes.\n\nIf you did not request a password reset, please ignore this email.\n\nThanks,\nThe XCE Team`, html: `<p>Hello ${accountExists.username || 'User'},</p><p>Your password reset code is: <strong>${resetCode}</strong></p><p>This code will expire in 15 minutes.</p><p>If you did not request a password reset, please ignore this email.</p><p>Thanks,<br>The XCE Team</p>`, }; await transporter.sendMail(mailOptions); console.warn(`[Handler] Password reset email sent to ${emailToReset}.`) } else { console.warn(`[Handler] No account found for email: ${emailToReset}. Still returning generic success message to prevent enumeration.`) } console.log("[Handler] Processing complete. Returning generic success message."); return res.status(200).json({ message: 'If an account with that email address exists, instructions to reset your password have been sent.' }) } catch (err) { console.error('[Handler] Error during password reset request processing:', err); return res.status(500).json({ error: 'An internal server error occurred.' }) } } 
signup.js: 
import bcrypt from 'bcryptjs'; import jwt from 'jsonwebtoken'; import { readAccount, writeAccount, findAccount } from './db'; export const config = { api: { bodyParser: true, }, }; export default async function handler(req, res) { console.warn(`/api/signup ${req.method} invoked`); if (req.method !== 'POST') { return res.status(405).end() } let username, password, email; try { const body = typeof req.body === 'string' ? JSON.parse(req.body) : req.body; username = body.username; password = body.password; email = body.email; if (!username || !password || !email) { return res.status(400).json({ error: 'Username, password, and email are required.' }) } } catch (err) { return res.status(400).json({ error: 'Invalid JSON' }) } try { const accountWithSameEmail = await findAccount(a => a.email === email); if (accountWithSameEmail && accountWithSameEmail.username !== username) { return res.status(400).json({ error: 'Email is already in use by another account.' }) } let accountToSave; let httpStatus = 201; const existingAccount = await readAccount(username); if (existingAccount) { if (existingAccount.passwordHash) { return res.status(400).json({ error: 'Username taken' }) } accountToSave = existingAccount; httpStatus = 200 } else { accountToSave = { username, tier: 'T1', status: 'free', stripeSubscriptionId: null, currentPeriodEnd: 0, } } const passwordHash = await bcrypt.hash(password, 10); accountToSave.passwordHash = passwordHash; accountToSave.email = email; await writeAccount(accountToSave); const token = jwt.sign({ username: accountToSave.username }, process.env.JWT_SECRET, { expiresIn: '1h', }); console.warn(`User processed: ${username}. Status: ${httpStatus}`); res.status(httpStatus).json({ token }) } catch (err) { console.error('Error during signup process', err); return res.status(500).json({ error: 'Internal server error' }) } } 
subscription-status.js: 
import jwt from 'jsonwebtoken'; import { readAccount } from './db'; export default async function handler(req, res) { const authHeader = req.headers.authorization; if (!authHeader || !authHeader.startsWith('Bearer ')) { return res.status(401).json({ error: 'Authorization header missing or invalid' }) } const token = authHeader.split(' ')[1]; if (!token) { return res.status(401).json({ error: 'Token missing' }) } let payload; try { payload = jwt.verify(token, process.env.JWT_SECRET) } catch (err) { return res.status(401).json({ error: 'Invalid or expired token' }) } const acct = await readAccount(payload.username); if (!acct) { return res.status(404).json({ error: 'Account not found' }) } res.json({ status: acct.status, tier: acct.tier, current_period_end: acct.currentPeriodEnd, server_time: Math.floor(Date.now() / 1000) }) } 
webhook.js: 
import { buffer } from 'micro'; import Stripe from 'stripe'; import { upsertAccount } from './account.js'; import { findAccount } from './db.js'; export const config = { api: { bodyParser: false } }; const stripe = new Stripe(process.env.TEST_STRIPE_SECRET_KEY); export default async function handler(req, res) { if (req.method !== 'POST') { res.setHeader('Allow', 'POST'); return res.status(405).end('Method Not Allowed') } let event; try { const buf = await buffer(req); event = stripe.webhooks.constructEvent(buf, req.headers['stripe-signature'], process.env.TEST_STRIPE_WEBHOOK_SECRET); console.warn(`Stripe event: ${event.type}`) } catch (err) { console.error('Webhook signature failed:', err.message); return res.status(400).send(`Webhook Error: ${err.message}`) } const obj = event.data.object; let username = null; let subscriptionId = null; let sub = null; let email = null; if (event.type === 'checkout.session.completed') { username = (obj.custom_fields || []).find(f => f.key === 'xceusername')?.text?.value; subscriptionId = obj.subscription; email = obj.customer_details?.email } else if (event.type === 'invoice.payment_succeeded') { subscriptionId = obj.subscription } else if (event.type.startsWith('customer.subscription.')) { subscriptionId = obj.id; sub = obj } if (!username && subscriptionId) { const account = await findAccount(acc => acc.stripeSubscriptionId === subscriptionId); if (account) { username = account.username; console.warn(`Found user '${username}' via subscription ID ${subscriptionId}`) } } if (!sub && subscriptionId) { try { sub = await stripe.subscriptions.retrieve(subscriptionId) } catch (err) { console.error(`Error retrieving subscription ${subscriptionId}:`, err); sub = null } } if (sub && username) { try { const acct = await upsertAccount({ username, sub, email }); console.warn(`Upserted ${acct.username} → tier=${acct.tier}, expiresUnix=${acct.currentPeriodEnd}`) } catch (err) { console.error('upsertAccount error:', err) } } else { console.warn('Skipping upsert: missing username or subscription object.') } res.json({ received: true }) } 
